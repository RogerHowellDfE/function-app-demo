name: CI/CD Pipeline

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**/*.md'
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**/*.md'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: function-app-demo
  MAX_RETRIES: 20
  SLEEP_TIME: 10

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    permissions: 
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Verify app builds, and that tests pass
      run: |
        dotnet restore
        dotnet build   --configuration Release --no-restore
        dotnet test    --configuration Release --no-restore
        dotnet publish --configuration Release --no-restore --output ./publish

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: function-app-demo
        path: ./publish

  build_and_push_image:
    runs-on: ubuntu-latest
    needs: build_and_test

    permissions: 
      packages: write

    outputs:
      image: ${{ steps.build_image.outputs.image }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push docker image
      id: build_image
      uses: DFE-Digital/github-actions/build-docker-image@master
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push_image

    permissions:
      id-token: write
      contents: read

    strategy:
      matrix:
        environment: [Development, Test, Production]

    env:
      RESOURCE_GROUP: fa-docker-demo
      SHORT_NAME: ${{ fromJSON('{"Development":"dev","Test":"test","Production":"prod"}')[matrix.environment] }}
      FUNCTION_APP_NAME: ${{ fromJSON('{"Development":"fa-docker-demo-dev","Test":"fa-docker-demo-test","Production":"fa-docker-demo-prod"}')[matrix.environment] }}
      TEMP_KEY_NAME: temp_key_cicd_smoketest
      IMAGE: ${{ needs.build_and_push_image.outputs.image }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4


    ## Login to Azure. 
    ## Note that these details are environment-specific.
    - name: Azure Login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}


    - name: Debug - Print Image and Variables
      run: |
        echo "IMAGE               : ${{ env.IMAGE }}"
        echo "REGISTRY            : ${{ env.REGISTRY }}"
        echo "IMAGE_NAME          : ${{ env.IMAGE_NAME }}"
        echo "GITHUB_REF          : ${{ github.ref }}"
        echo "GITHUB_SHA          : ${{ github.sha }}"
        echo "SHORT_NAME          : ${{ env.SHORT_NAME }}"
        echo "FUNCTION_APP_NAME   : ${{ env.FUNCTION_APP_NAME }}"


    ## Do a smoke test to verify the function app is repsponding to HTTP requests
    ## Note:
    ## - We would typically like to verify the version of the app too, to ensure that the correct version is deployed 
    ##   (e.g., it could be that the previous version never got stopped, and the new version never got started)
    ## - Additional health checks might validate the app is fully operational (e.g., validating database connections, etc.)
    - name: Smoke Test - Verify Public HealthCheck
      shell: pwsh
      run: ./scripts/smoketest.ps1 -url "${{ steps.fa.outputs.app-url }}/api/HealthCheck" -maxRetries ${{ env.MAX_RETRIES }} -sleepTime ${{ env.SLEEP_TIME }}


    ## We programatically create a temporary API key for smoke tests, whose lifetime is limited to the duration of the workflow run
    ## Note: Do not touch API keys in production
    - name: Add Temporary API Key for Smoke Test
      id: add_temp_api_key
      if: matrix.environment != 'Production'
      shell: pwsh
      run: |
        az functionapp keys set --name ${{ env.FUNCTION_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --key-type functionKeys --key-name ${{ env.TEMP_KEY_NAME }}
        $TEMP_API_KEY = az functionapp keys list --name ${{ env.FUNCTION_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query "functionKeys.${{ env.TEMP_KEY_NAME }}" -o tsv
        echo "TEMP_API_KEY=$TEMP_API_KEY" >> $env:GITHUB_ENV
        echo "::add-mask::$TEMP_API_KEY"
        if (-not $TEMP_API_KEY) {
          Write-Error "TEMP_API_KEY is empty. Exiting..."
          exit 1
        }

    ## Do an authenticated smoke test in non-production environments
    ## Don't do authenticated tests in production
    - name: Smoke Test - Verify Authenticated Function1
      if: matrix.environment != 'Production'
      shell: pwsh
      run: ./scripts/smoketest.ps1 -url "${{ steps.fa.outputs.app-url }}/api/Function1" -maxRetries ${{ env.MAX_RETRIES }} -sleepTime ${{ env.SLEEP_TIME }} -headers @{ "x-functions-key" = "${{ env.TEMP_API_KEY }}" }
      

    ## TODO: Here we would do in-depth automated tests (e.g., Postman scripts, Selenium tests, etc.)
    ## These tests might be restricted to specific environments e.g.:
    ## - in-depth end-to-end functional tests in the "Test" environment, 
    ## - security / performance tests in a "Pre-Production" / "SIT" environment
    ## For simplicity, we are skipping this step in this demo
       

    ## Fail-safe to remove temporary API key
    ## Note: As a fail-safe, we always do this in all environments including production
    - name: Remove Temporary API Key
      if: always()
      run: |
        az functionapp keys delete --name ${{ env.FUNCTION_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --key-type functionKeys --key-name ${{ env.TEMP_KEY_NAME }} || echo "Key not found, skipping deletion"

